import React, { useState, useRef, useEffect } from 'react';
import { Send, MessageCircle, X, Bot, Edit, Check, Calendar, HelpCircle, Bell, Phone, Shield } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from './ui/tooltip';
import { useVoiceChat } from '../hooks/useVoiceChat';
import { useViewportHeight } from '../hooks/useViewportHeight';
import { VoiceControls } from './VoiceControls';
import { VoiceSettings } from './VoiceSettings';
import { CallInterface } from './CallInterface';
import { WelcomeScreen } from './WelcomeScreen';
import './ChatbotWidget.css';
interface Message {
  id: string;
  text: string;
  sender: 'user' | 'bot';
  timestamp: Date;
  showSuggestions?: boolean;
  sending?: boolean;
}

interface WelcomeButton {
  id: string;
  text: string;
  message: string; // Message to send when clicked
  icon?: string; // Optional icon class or emoji
}
interface ChatbotWidgetProps {
  webhookUrl?: string;
  title?: string;
  bio?: string;
  placeholder?: string;
  position?: 'bottom-right' | 'bottom-left';
  primaryColor?: string;
  secondaryColor?: string;
  chatBackground?: string;
  botTextColor?: string;
  userTextColor?: string;
  headerGradientColor?: string;
  headerMainColor?: string;
  userId?: string;
  clinicName?: string;
  clinicId?: string;
  logoUrl?: string;
  logoFile?: File;
  avatarUrl?: string;
  avatarFile?: File;
  welcomeMessage?: string;
  welcomeTooltipMessage?: string;
  showWelcomeScreen?: boolean;
  companyLogo?: string;
  welcomeButtons?: WelcomeButton[];
  admin?: boolean;
  isVoiceEnabled?: boolean;
  isElevenLabsEnabled?: boolean;
  elevenLabsAgentId?: string;
  logoBackgroundColor?: string;
  logoBorderColor?: string;
  headerButtonColor?: string;
  fontFamily?: string;
  companyName?: string;
  agentName?: string;
  callToAction?: string;
}

// Helper function to render text with line breaks
const renderTextWithLineBreaks = (text: string) => {
  return text.split('\n').map((line, index) => <span key={index}>
      {line}
      {index < text.split('\n').length - 1 && <br />}
    </span>);
};

// Update the logError function to include timestamp and initializationUrl
const logError = async (errorData: {
  from: 'webhook' | 'UI' | 'initialization';
  errorCode: number;
  errorMessage: string;
  errorStack: string;
  payloadToWebHook: any;
  initializationUrl: string;
}) => {
  try {
    await fetch('https://luccatora.app.n8n.cloud/webhook/webbot-error', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        ...errorData,
        timestamp: new Date().toISOString()
      })
    });
  } catch (logError) {
    console.error('Failed to log error:', logError);
  }
};

// Add a global error boundary for the entire chatbot
const handleGlobalError = (error: Error) => {
  logError({
    from: 'UI',
    errorCode: 500,
    errorMessage: error.message,
    errorStack: error.stack || '',
    payloadToWebHook: null,
    initializationUrl: window.location.href
  });
};
export const ChatbotWidget: React.FC<ChatbotWidgetProps> = ({
  webhookUrl = 'https://luccatora.app.n8n.cloud/webhook/webbot-test',
  title = 'MediFlow',
  bio = 'Your medical assistant',
  placeholder = 'Type your message...',
  position = 'bottom-right',
  primaryColor = '#6366f1',
  secondaryColor = '#f1f5f9',
  chatBackground = '#ffffff',
  botTextColor = '#1f2937',
  userTextColor = '#ffffff',
  headerGradientColor = '#8b5cf6',
  headerMainColor = '#6366f1',
  userId = 'anonymous',
  // Keep as fallback but won't be used for webhook
  clinicName = 'Demo Clinic',
  clinicId = '104',
  logoUrl = '/lovable-uploads/fd9d4dbf-9035-4de8-a3a1-81089fcac665.png',
  logoFile,
  avatarUrl = '/lovable-uploads/1f938225-daa7-46d3-a44e-d951e492fcd4.png',
  avatarFile,
  welcomeMessage = 'Hi! I\'m your medical assistant. How can I help you today?',
  welcomeTooltipMessage = 'Click to start chatting with our AI assistant!',
  showWelcomeScreen = false,
  companyLogo,
  welcomeButtons = [
    { id: '1', text: 'Get Support', message: 'I need help with support', icon: 'ðŸ†˜' },
    { id: '2', text: 'General Inquiry', message: 'I have a general question', icon: 'ðŸ’¬' },
    { id: '3', text: 'Book Appointment', message: 'I would like to book an appointment', icon: 'ðŸ“…' }
  ],
  admin = false,
  isVoiceEnabled = true,
  isElevenLabsEnabled = false,
  elevenLabsAgentId = 'agent_01k04zwwq3fv5acgzdwmbvfk8k',
  logoBackgroundColor = 'transparent',
  logoBorderColor = '#e5e7eb',
  headerButtonColor = '#ffffff',
  companyName = 'MediFlow',
  agentName = 'Medical Assistant',
  callToAction = 'Start a conversation'
}) => {
  // Create logo URL from file if provided
  const [logoSrc, setLogoSrc] = useState<string>(logoUrl);
  const [avatarSrc, setAvatarSrc] = useState<string>(avatarUrl);
  
  useEffect(() => {
    if (logoFile) {
      const url = URL.createObjectURL(logoFile);
      setLogoSrc(url);
      return () => URL.revokeObjectURL(url);
    } else {
      setLogoSrc(logoUrl);
    }
  }, [logoFile, logoUrl]);

  useEffect(() => {
    if (avatarFile) {
      const url = URL.createObjectURL(avatarFile);
      setAvatarSrc(url);
      return () => URL.revokeObjectURL(url);
    } else {
      setAvatarSrc(avatarUrl);
    }
  }, [avatarFile, avatarUrl]);
  // Voice functionality - only initialize if voice is enabled
  const [isVoiceMode, setIsVoiceMode] = useState(false);
  const [autoPlayResponses, setAutoPlayResponses] = useState(true);

  // NEW: Call interface state for ElevenLabs voice agent
  const [isCallMode, setIsCallMode] = useState(false);

  // Voice chat hook - only use if voice is enabled
  const voiceChat = useVoiceChat({
    onTranscription: (text: string) => {
      if (text.trim()) {
        sendMessage(text);
      }
    },
    isVoiceEnabled: isVoiceEnabled && isVoiceMode,
    autoPlayResponses: isVoiceEnabled ? autoPlayResponses : false
  });

  // Conditionally destructure voice chat properties
  const {
    isRecording = false,
    isProcessing = false,
    recordingTimer = 0,
    isSpeaking = false,
    voicePermissionDenied = false,
    selectedVoice = 'bark',
    startRecording = () => {},
    stopRecording = () => {},
    speakText = () => {},
    stopSpeaking = () => {},
    setSelectedVoice = () => {}
  } = isVoiceEnabled ? voiceChat : {};

  // Add error state
  const [hasError, setHasError] = useState(false);
  
  // Welcome screen state
  const [showingWelcomeScreen, setShowingWelcomeScreen] = useState(showWelcomeScreen && !messages.length);

  // Generate or retrieve session ID - this will be our primary user identifier
  const generateSessionId = () => {
    if (typeof window !== 'undefined') {
      try {
        return crypto.randomUUID();
      } catch {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }
    }
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  };
  const getOrCreateSessionId = () => {
    if (typeof window === 'undefined') return generateSessionId();
    let sessionId = sessionStorage.getItem('chatbot-session-id');
    if (!sessionId) {
      sessionId = generateSessionId();
      sessionStorage.setItem('chatbot-session-id', sessionId);
    }
    return sessionId;
  };
  const [sessionId] = useState(() => getOrCreateSessionId());
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null);
  const [editingText, setEditingText] = useState('');
  const [editingError, setEditingError] = useState('');
  const [hasUnreadMessages, setHasUnreadMessages] = useState(false);
  const [playingMessageId, setPlayingMessageId] = useState<string | null>(null);
  const [isNotificationEnabled, setIsNotificationEnabled] = useState(true);
  const [suggestionsDisabled, setSuggestionsDisabled] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const editingTextareaRef = useRef<HTMLTextAreaElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);
  const chatWindowRef = useRef<HTMLDivElement>(null);
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  
  // Messenger-like scroll behavior states
  const [isAtBottom, setIsAtBottom] = useState(true);
  const [showNewMessageIndicator, setShowNewMessageIndicator] = useState(false);

  // Mobile detection state
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const [isSmallMobile, setIsSmallMobile] = useState(window.innerWidth <= 480);
  
  // Dynamic viewport height for mobile
  const viewportHeight = useViewportHeight();
  
  // Track if user is at bottom for smart scrolling
  const [isUserAtBottom, setIsUserAtBottom] = useState(true);

  // Debounce utility
  const debounce = (func: Function, wait: number) => {
    let timeout: NodeJS.Timeout;
    return (...args: any[]) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => func(...args), wait);
    };
  };

  // Simple mobile detection with debounce
  useEffect(() => {
    const handleResize = debounce(() => {
      const vw = window.innerWidth;
      setIsMobile(vw <= 768);
      setIsSmallMobile(vw <= 480);
    }, 150);

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Simplified input focus handling - no viewport manipulation
  useEffect(() => {
    const handleInputFocus = () => {
      // Scroll last message into view when keyboard opens
      setTimeout(() => {
        if (messagesContainerRef.current) {
          const lastMessage = messagesContainerRef.current.lastElementChild;
          lastMessage?.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }
      }, 300); // After keyboard animation
    };

    const handleInputBlur = () => {
      // Nothing to clean up
    };

    const inputElement = inputRef.current;
    if (inputElement) {
      inputElement.addEventListener('focus', handleInputFocus);
      inputElement.addEventListener('blur', handleInputBlur);

      return () => {
        inputElement.removeEventListener('focus', handleInputFocus);
        inputElement.removeEventListener('blur', handleInputBlur);
      };
    }
  }, [isOpen]);

  // Update welcome message when prop changes
  useEffect(() => {
    const welcomeMsg: Message = {
      id: 'welcome-1',
      text: welcomeMessage,
      sender: 'bot',
      timestamp: new Date(),
      showSuggestions: true
    };
    setMessages([welcomeMsg]);
  }, [welcomeMessage]);
  
  // Track scroll position to know if user is at bottom
  useEffect(() => {
    const container = messagesContainerRef.current;
    if (!container) return;

    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = container;
      const isNearBottom = scrollTop + clientHeight >= scrollHeight - 50;
      setIsUserAtBottom(isNearBottom);
    };

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, []);

  // Set CSS custom properties for theming
  useEffect(() => {
    // Find the chatbot container
    const container = document.querySelector('.chatbot-widget-container') as HTMLElement;
    if (container) {
      // Apply variables to the container
      container.style.setProperty('--chatbot-primary', primaryColor);
      container.style.setProperty('--chatbot-secondary', secondaryColor);
      container.style.setProperty('--chatbot-background', chatBackground);
      container.style.setProperty('--chatbot-bot-text', botTextColor);
      container.style.setProperty('--chatbot-user-text', userTextColor);
      container.style.setProperty('--chatbot-header-gradient', headerGradientColor);
      container.style.setProperty('--chatbot-header-main', headerMainColor);
      container.style.setProperty('--chatbot-logo-background', logoBackgroundColor);
      container.style.setProperty('--chatbot-logo-border', logoBorderColor);

      // Also apply to the root element to ensure they cascade properly
      document.documentElement.style.setProperty('--chatbot-primary', primaryColor);
      document.documentElement.style.setProperty('--chatbot-secondary', secondaryColor);
      document.documentElement.style.setProperty('--chatbot-background', chatBackground);
      document.documentElement.style.setProperty('--chatbot-bot-text', botTextColor);
      document.documentElement.style.setProperty('--chatbot-user-text', userTextColor);
      document.documentElement.style.setProperty('--chatbot-header-gradient', headerGradientColor);
      document.documentElement.style.setProperty('--chatbot-header-main', headerMainColor);
      document.documentElement.style.setProperty('--chatbot-logo-background', logoBackgroundColor);
      document.documentElement.style.setProperty('--chatbot-logo-border', logoBorderColor);

      // Force a reflow to ensure styles are applied
      container.offsetHeight;
      console.log('Chatbot styles updated:', {
        primaryColor,
        secondaryColor,
        chatBackground,
        botTextColor,
        userTextColor,
        headerGradientColor,
        headerMainColor
      });
    } else {
      console.warn('Chatbot container not found. Styles not applied.');
    }
  }, [primaryColor, secondaryColor, chatBackground, botTextColor, userTextColor, headerGradientColor, headerMainColor, logoBackgroundColor, logoBorderColor]);
  // Messenger-like scroll detection
  const checkIfAtBottom = () => {
    const container = messagesContainerRef.current;
    if (!container) return true;
    
    // Check if user is within 50px of bottom (threshold for "at bottom")
    const threshold = 50;
    const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
    return isNearBottom;
  };

  // Handle scroll events to detect position
  const handleScroll = () => {
    const atBottom = checkIfAtBottom();
    setIsAtBottom(atBottom);
    
    // Hide new message indicator if scrolled to bottom
    if (atBottom && showNewMessageIndicator) {
      setShowNewMessageIndicator(false);
    }
  };

  // Smart scroll to bottom (only if already at bottom or forced)
  const scrollToBottom = (instant = false) => {
    if (!messagesContainerRef.current) return;
    
    // Use requestAnimationFrame for smoother scrolling
    requestAnimationFrame(() => {
      const container = messagesContainerRef.current;
      if (container) {
        container.scrollTo({
          top: container.scrollHeight,
          behavior: instant ? 'instant' : 'smooth'
        });
      }
    });
  };
  
  // Scroll to bottom when user clicks new message indicator
  const handleNewMessageClick = () => {
    scrollToBottom(false); // Use smooth scroll for user action
    setShowNewMessageIndicator(false);
  };

  // Add MutationObserver for auto-scroll on content changes
  useEffect(() => {
    const messagesContainer = document.querySelector('.chatbot-widget-messages');
    if (!messagesContainer) return;

    const observer = new MutationObserver(() => {
      // Check if user is near bottom before auto-scrolling
      const isNearBottom = messagesContainer.scrollTop + messagesContainer.clientHeight >= messagesContainer.scrollHeight - 100;
      if (isNearBottom) {
        scrollToBottom();
      }
    });

    observer.observe(messagesContainer, {
      childList: true,
      subtree: true
    });

    return () => observer.disconnect();
  }, [isOpen]);

  useEffect(() => {
    if (messages.length > 0) {
      const lastMessage = messages[messages.length - 1];
      if (lastMessage.sender === 'bot') {
        // Only auto-scroll for bot messages if user was already at bottom
        if (isUserAtBottom) {
          setTimeout(() => scrollToBottom(false), 100);
        }
      }
    }
  }, [messages, isUserAtBottom]);
  useEffect(() => {
    if (isOpen) {
      setHasUnreadMessages(false);
      // Scroll to bottom when opening chat
      setTimeout(() => {
        scrollToBottom(true);
      }, 100);
    }
  }, [isOpen]);

  // Add state for tooltip visibility with 2-second delay
  const [showWelcomeTooltip, setShowWelcomeTooltip] = useState(false);
  const tooltipTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Show tooltip after 2 seconds on mount, no auto-hide
  useEffect(() => {
    // Show tooltip after 2 seconds
    tooltipTimeoutRef.current = setTimeout(() => {
      setShowWelcomeTooltip(true);
    }, 2000);

    // Clear timeout when component unmounts
    return () => {
      if (tooltipTimeoutRef.current) {
        clearTimeout(tooltipTimeoutRef.current);
      }
    };
  }, []);

  // Hide tooltip when chat opens
  useEffect(() => {
    if (isOpen) {
      setShowWelcomeTooltip(false);
      if (tooltipTimeoutRef.current) {
        clearTimeout(tooltipTimeoutRef.current);
      }
    }
  }, [isOpen]);

  // Add state for chat button click
  const [chatButtonClickCount, setChatButtonClickCount] = useState(0);

  // Handle chat button click - hide tooltip immediately
  const handleChatButtonClick = () => {
    setShowWelcomeTooltip(false);
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current);
    }
    setIsOpen(true);
  };

  // Add missing function: sendCorrectionToWebhook
  const sendCorrectionToWebhook = async (originalText: string, correctedText: string) => {
    try {
      if (!webhookUrl) {
        console.warn('Webhook URL not configured for correction');
        return;
      }
      const correctionPayload = {
        type: 'correction',
        originalMessage: originalText,
        correctedMessage: correctedText,
        userId: sessionId,
        clinicName,
        clinicId,
        timestamp: new Date().toISOString()
      };
      console.log('Sending correction to webhook:', correctionPayload);
      await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(correctionPayload)
      });
    } catch (error) {
      console.error('Error sending correction to webhook:', error);
      // Log error for debugging
      await logError({
        from: 'webhook',
        errorCode: 500,
        errorMessage: error instanceof Error ? error.message : 'Unknown correction error',
        errorStack: error instanceof Error ? error.stack || '' : '',
        payloadToWebHook: {
          type: 'correction',
          originalMessage: originalText,
          correctedMessage: correctedText,
          userId: sessionId,
          clinicName,
          clinicId
        },
        initializationUrl: window.location.href
      });
    }
  };

  // Add missing function: handleSuggestionClick
  const handleSuggestionClick = (suggestion: string) => {
    if (suggestionsDisabled) return;

    // Send the suggestion as a message
    sendMessage(suggestion);

    // Disable suggestions after clicking
    setSuggestionsDisabled(true);
  };

  // Handle welcome button clicks
  const handleWelcomeButtonClick = (message: string) => {
    // Transition to regular chat after button click
    setShowingWelcomeScreen(false);
    sendMessage(message);
  };

  // Enhanced sendMessage function with conditional voice response
  const sendMessage = async (messageText?: string, retryCount = 0) => {
    const textToSend = messageText || inputMessage.trim();
    if (!textToSend || isLoading) return;
    const userMessage: Message = {
      id: Date.now().toString(),
      text: textToSend,
      sender: 'user',
      timestamp: new Date(),
      sending: true
    };
    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    
    // Force scroll to bottom after user sends message
    setTimeout(() => scrollToBottom(false), 100);
    
    setIsLoading(true);
    setIsTyping(true);
    setHasError(false);
    setSuggestionsDisabled(true);
    try {
      if (!webhookUrl) {
        throw new Error('Webhook URL not configured');
      }

      // Always use sessionId as userId for webhook requests - never send anonymous
      const webhookPayload = {
        message: textToSend,
        userId: sessionId,
        // Use sessionId instead of userId prop
        clinicName,
        clinicId,
        timestamp: new Date().toISOString()
      };
      console.log('Sending webhook payload:', webhookPayload);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);
      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(webhookPayload),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }
      const data = await response.json();
      console.log('Webhook response:', data);
      let botResponse = 'Sorry, I could not process your request.';
      if (Array.isArray(data) && data.length > 0 && data[0].output) {
        botResponse = data[0].output;
      } else if (data.message) {
        botResponse = data.message;
      } else if (data.response) {
        botResponse = data.response;
      } else if (typeof data === 'string') {
        botResponse = data;
      }
      const botMessage: Message = {
        id: (Date.now() + 1).toString(),
        text: botResponse,
        sender: 'bot',
        timestamp: new Date()
      };
      // Update user message to remove sending state and add bot message
      setMessages(prev => [
        ...prev.map(msg => 
          msg.timestamp === userMessage.timestamp 
            ? { ...msg, sending: false } 
            : msg
        ),
        botMessage
      ]);

      // Auto-play response if voice is enabled and voice mode is on
      if (isVoiceEnabled && isVoiceMode && autoPlayResponses && !isSpeaking) {
        setTimeout(() => {
          speakText(botResponse);
        }, 500);
      }

      // Show notification if widget is closed
      if (!isOpen && isNotificationEnabled) {
        setHasUnreadMessages(true);
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(title, {
            body: botResponse.length > 50 ? botResponse.substring(0, 50) + '...' : botResponse,
            icon: logoUrl || '/favicon.ico'
          });
        }
      }
    } catch (error) {
      console.error('Error sending message:', error);

      // Log error for debugging
      await logError({
        from: 'webhook',
        errorCode: 500,
        errorMessage: error instanceof Error ? error.message : 'Unknown error',
        errorStack: error instanceof Error ? error.stack || '' : '',
        payloadToWebHook: {
          message: textToSend,
          userId: sessionId,
          // Log sessionId, not anonymous
          clinicName,
          clinicId,
          timestamp: new Date().toISOString()
        },
        initializationUrl: window.location.href
      });

      // Retry logic
      if (retryCount < 2 && error instanceof Error && error.name !== 'AbortError') {
        console.log(`Retrying... Attempt ${retryCount + 1}`);
        setTimeout(() => {
          sendMessage(textToSend, retryCount + 1);
        }, 1000 * (retryCount + 1));
        return;
      }
      setHasError(true);
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        text: retryCount >= 2 ? 'I apologize, but I\'m having trouble connecting right now. Please try again in a moment.' : 'Sorry, I encountered an error. Please try again.',
        sender: 'bot',
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
      setIsTyping(false);
    }
  };
  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (inputMessage.trim() && !isTyping) {
        sendMessage(inputMessage);
        // Reset textarea height after sending
        if (inputRef.current) {
          inputRef.current.style.height = '44px';
        }
      }
    }
  };
  const handleEditMessage = (message: Message) => {
    setEditingMessageId(message.id);
    setEditingText(message.text);
    setEditingError('');
  };
  const handleSaveEdit = async (messageId: string) => {
    const trimmedText = editingText.trim();
    if (!trimmedText) {
      setEditingError('Message cannot be empty');
      return;
    }
    const message = messages.find(m => m.id === messageId);
    if (!message) return;
    const originalText = message.text;
    if (trimmedText !== originalText) {
      setMessages(prev => prev.map(m => m.id === messageId ? {
        ...m,
        text: trimmedText
      } : m));
      await sendCorrectionToWebhook(originalText, trimmedText);
    }
    setEditingMessageId(null);
    setEditingText('');
    setEditingError('');
  };
  const handleCancelEdit = () => {
    setEditingMessageId(null);
    setEditingText('');
    setEditingError('');
  };
  const handleEditKeyPress = (e: React.KeyboardEvent, messageId: string) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSaveEdit(messageId);
    } else if (e.key === 'Escape') {
      e.preventDefault();
      handleCancelEdit();
    }
  };
  const isEditingTextValid = editingText.trim().length > 0;
  const toggleVoiceMode = () => {
    if (!isVoiceEnabled) return; // Don't allow toggle if voice is disabled
    setIsVoiceMode(!isVoiceMode);
    if (isVoiceMode && stopSpeaking) {
      stopSpeaking();
    }
  };
  const toggleAutoPlay = () => {
    if (!isVoiceEnabled) return; // Don't allow toggle if voice is disabled
    setAutoPlayResponses(!autoPlayResponses);
    if (!autoPlayResponses && stopSpeaking) {
      stopSpeaking();
    }
  };

  // Truncate session ID for display (show first 8 characters)
  const displaySessionId = sessionId.length > 8 ? `${sessionId.substring(0, 8)}...` : sessionId;

  // Helper function to get hover color (slightly darker than the base color)
  const getHoverColor = (color: string) => {
    // Simple way to darken a hex color
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      const num = parseInt(hex, 16);
      const r = Math.max(0, (num >> 16) - 20);
      const g = Math.max(0, (num >> 8 & 0x00FF) - 20);
      const b = Math.max(0, (num & 0x0000FF) - 20);
      return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
    }
    return color;
  };
  return (
    <div 
      className={`chatbot-widget-container chatbot-widget-${position}`} 
      style={{
        position: 'fixed',
        bottom: '1.5rem',
        right: position === 'bottom-right' ? '1.5rem' : 'auto',
        left: position === 'bottom-left' ? '1.5rem' : 'auto',
        top: 'auto',
        zIndex: 2147483647
      }}
      ref={(el) => {
        if (el) {
          console.log('Widget position:', {
            position: position,
            computedStyle: window.getComputedStyle(el),
            bottom: window.getComputedStyle(el).bottom,
            top: window.getComputedStyle(el).top,
            right: window.getComputedStyle(el).right,
            left: window.getComputedStyle(el).left
          });
        }
      }}
    >
      {/* Chat Window */}
      {isOpen && <div ref={chatWindowRef} className="chatbot-widget-window chatbot-widget-animate-in" style={{
      height: isMobile ? `${viewportHeight}px` : '600px',
      maxHeight: isMobile ? `${viewportHeight}px` : '600px',
      display: 'flex',
      flexDirection: 'column',
      paddingBottom: isMobile ? 'env(safe-area-inset-bottom)' : '0'
    }}>
          {/* Header */}
          <div className="chatbot-widget-header" style={{
        backgroundColor: primaryColor
      }}>
            <div className="chatbot-widget-header-content">
              <div className="chatbot-widget-header-avatar">
                {logoSrc && <img src={logoSrc} alt="Logo" className="chatbot-widget-logo" onError={e => {
              console.error('Logo failed to load:', logoSrc);
              e.currentTarget.style.display = 'none';
            }} onLoad={() => {
              console.log('Logo loaded successfully:', logoSrc);
            }} />}
              </div>
              <div>
                <h3 className="chatbot-widget-header-title">{title}</h3>
                <p className="chatbot-widget-header-subtitle">
                  {bio}
                  {isVoiceEnabled && isVoiceMode && <span style={{
                marginLeft: '8px',
                fontSize: '10px'
              }}>ðŸŽ¤ Voice Mode</span>}
                </p>
              </div>
            </div>
            <div className="chatbot-widget-header-actions">
              {/* NEW: Voice Agent Call Button - only show if ElevenLabs is enabled */}
              {isElevenLabsEnabled && elevenLabsAgentId && (
                <button className="chatbot-widget-button" onClick={() => setIsCallMode(true)} title="Start a call" style={{
              marginRight: '2px',
              width: '48px',
              height: '48px',
              padding: '0',
              display: 'flex !important',
              alignItems: 'center',
              justifyContent: 'center',
              backgroundColor: 'transparent',
              border: 'none',
              borderRadius: '50%',
              cursor: 'pointer',
              opacity: '1',
              visibility: 'visible'
            }}>
                  <Phone style={{
                width: '26px',
                height: '26px',
                color: '#1f2937 !important'
              }} className="bg-transparent" />
                </button>
              )}

              {/* Privacy Policy Button */}
              <button 
                className="chatbot-widget-button" 
                onClick={() => window.open('/privacy-policy', '_blank')} 
                title="Privacy Policy" 
                style={{
                  marginRight: '0px',
                  width: '32px',
                  height: '32px',
                  padding: '0',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  backgroundColor: 'transparent',
                  border: 'none',
                  borderRadius: '50%',
                  cursor: 'pointer',
                  opacity: '0.8',
                  transition: 'opacity 0.2s ease'
                }}
                onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                onMouseLeave={(e) => e.currentTarget.style.opacity = '0.8'}
              >
                <Shield style={{
                  width: '16px',
                  height: '16px',
                  color: headerButtonColor || '#ffffff'
                }} />
              </button>
              
              <button className="chatbot-widget-button" onClick={() => setIsOpen(false)}>
                <X style={{
              width: '16px',
              height: '16px'
            }} />
              </button>
            </div>
          </div>
          
          {/* NEW: Conditional rendering for Call Interface or Regular Chat */}
        {isCallMode ? <CallInterface primaryColor={primaryColor} secondaryColor={secondaryColor} textColor={botTextColor} chatBackground={chatBackground} logoUrl={avatarUrl} agentId={elevenLabsAgentId} onBackToChat={() => setIsCallMode(false)} /> : <>
              {/* Messages */}
              {hasError ? <div className="chatbot-widget-messages chatbot-widget-scrollbar" style={{
          backgroundColor: chatBackground,
          flex: 1,
          overflowY: 'auto',
          paddingBottom: window.innerWidth <= 768 ? undefined : '1rem'
        }}>
                      <div className="chatbot-widget-messages-content">
                        <p className="chatbot-widget-message-text">
                          We're experiencing some technical difficulties. Please refresh the page to try again.
                        </p>
                      </div>
                    </div> : <>
                    <div 
                      ref={messagesContainerRef}
                      className="chatbot-widget-messages chatbot-widget-scrollbar" 
                      style={{
                        backgroundColor: chatBackground,
                        flex: '1 1 0', // Proper flex: grow, shrink, no basis
                        overflowY: 'auto',
                        overflowX: 'hidden',
                        padding: '1rem',
                        position: 'relative'
                        // Removed scrollPaddingBottom and minHeight - CSS handles this
                      }}
                      onScroll={handleScroll}
                    >
                      {/* New Messages Indicator */}
                      {showNewMessageIndicator && (
                        <button
                          onClick={handleNewMessageClick}
                          style={{
                            position: 'absolute',
                            bottom: '20px',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            backgroundColor: primaryColor,
                            color: '#ffffff',
                            padding: '8px 16px',
                            borderRadius: '20px',
                            fontSize: '14px',
                            fontWeight: '600',
                            boxShadow: '0 2px 8px rgba(0, 0, 0, 0.2)',
                            zIndex: 10,
                            display: 'flex',
                            alignItems: 'center',
                            gap: '6px',
                            border: 'none',
                            cursor: 'pointer',
                            animation: 'chatbot-fade-in 0.3s ease-out'
                          }}
                        >
                          â†“ New Messages
                        </button>
                      )}
                      
                      {showingWelcomeScreen ? (
                        <WelcomeScreen
                          companyLogo={companyLogo}
                          title={title}
                          bio={bio}
                          welcomeMessage={welcomeMessage}
                          buttons={welcomeButtons}
                          primaryColor={primaryColor}
                          secondaryColor={secondaryColor}
                          chatBackground={chatBackground}
                          textColor={botTextColor}
                          onButtonClick={handleWelcomeButtonClick}
                          isMobile={isMobile}
                        />
                      ) : (
                        <div className="chatbot-widget-messages-content">
                          {messages.map((message, index) => (
                          <div 
                            key={message.id} 
                            className={`chatbot-widget-message ${message.sender === 'user' ? 'chatbot-widget-message-user' : 'chatbot-widget-message-bot'} ${editingMessageId === message.id ? 'editing' : ''} chatbot-message-animate`}
                            style={{}}
                          >
                            <div className={`chatbot-widget-message-bubble ${message.sender === 'user' ? 'chatbot-widget-message-bubble-user' : 'chatbot-widget-message-bubble-bot'} ${editingMessageId === message.id ? 'editing' : ''} ${isMobile ? 'message-bubble-mobile' : ''} ${message.sending ? 'sending' : ''}`} style={{
                  backgroundColor: message.sender === 'user' ? primaryColor : secondaryColor,
                  color: message.sender === 'user' ? userTextColor : botTextColor,
                  border: message.sender === 'bot' ? `1px solid ${secondaryColor === '#f1f5f9' ? '#e2e8f0' : 'rgba(0,0,0,0.1)'}` : 'none'
                }}>
                              {editingMessageId === message.id ? <div style={{
                    width: '100%'
                  }}>
                                  <div style={{
                      position: 'relative'
                    }}>
                                    <textarea ref={editingTextareaRef} value={editingText} onChange={e => {
                        setEditingText(e.target.value);
                        setEditingError('');
                      }} onKeyDown={e => handleEditKeyPress(e, message.id)} className={`chatbot-widget-textarea full-width ${editingError ? 'error' : ''}`} style={{
                        color: botTextColor,
                        backgroundColor: chatBackground
                      }} placeholder="Edit your message..." />
                                    {editingError && <div className="chatbot-widget-error">{editingError}</div>}
                                  </div>
                                  <div className="chatbot-widget-edit-controls">
                                    <button onClick={() => handleSaveEdit(message.id)} disabled={!isEditingTextValid} className="chatbot-widget-button" style={{
                        color: botTextColor,
                        opacity: !isEditingTextValid ? 0.5 : 1,
                        cursor: !isEditingTextValid ? 'not-allowed' : 'pointer'
                      }}>
                                      <Check style={{
                          width: '14px',
                          height: '14px'
                        }} />
                                    </button>
                                    <button onClick={handleCancelEdit} className="chatbot-widget-button" style={{
                        color: botTextColor
                      }}>
                                      <X style={{
                          width: '14px',
                          height: '14px'
                        }} />
                                    </button>
                                  </div>
                                </div> : <>
                                  <p className="chatbot-widget-message-text">
                                    {renderTextWithLineBreaks(message.text)}
                                  </p>
                                  
                                  {/* Suggestion Buttons - inside the welcome message bubble */}
                                  {message.showSuggestions && message.sender === 'bot' && !suggestionsDisabled && <div style={{
                      display: 'flex',
                      flexDirection: 'row',
                      gap: '6px',
                      marginTop: '12px',
                      flexWrap: 'nowrap',
                      justifyContent: 'flex-start'
                    }}>
                                      <button onClick={() => handleSuggestionClick('Book now')} disabled={suggestionsDisabled} style={{
                        backgroundColor: primaryColor,
                        border: 'none',
                        color: userTextColor,
                        padding: '8px 12px',
                        borderRadius: '20px',
                        fontSize: '12px',
                        fontWeight: '600',
                        cursor: suggestionsDisabled ? 'not-allowed' : 'pointer',
                        transition: 'all 0.2s ease',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '4px',
                        opacity: suggestionsDisabled ? 0.6 : 1,
                        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
                        whiteSpace: 'nowrap',
                        minWidth: 'auto'
                      }} onMouseEnter={e => {
                        if (!suggestionsDisabled) {
                          e.currentTarget.style.transform = 'translateY(-1px)';
                          e.currentTarget.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
                        }
                      }} onMouseLeave={e => {
                        if (!suggestionsDisabled) {
                          e.currentTarget.style.transform = 'translateY(0)';
                          e.currentTarget.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.15)';
                        }
                      }}>
                                        <Calendar size={14} />
                                        Book Now
                                      </button>
                                      <button onClick={() => handleSuggestionClick('Ask Question?')} disabled={suggestionsDisabled} style={{
                        backgroundColor: primaryColor,
                        border: 'none',
                        color: userTextColor,
                        padding: '8px 12px',
                        borderRadius: '20px',
                        fontSize: '12px',
                        fontWeight: '600',
                        cursor: suggestionsDisabled ? 'not-allowed' : 'pointer',
                        transition: 'all 0.2s ease',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '4px',
                        opacity: suggestionsDisabled ? 0.6 : 1,
                        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
                        whiteSpace: 'nowrap',
                        minWidth: 'auto'
                      }} onMouseEnter={e => {
                        if (!suggestionsDisabled) {
                          e.currentTarget.style.transform = 'translateY(-1px)';
                          e.currentTarget.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
                        }
                      }} onMouseLeave={e => {
                        if (!suggestionsDisabled) {
                          e.currentTarget.style.transform = 'translateY(0)';
                          e.currentTarget.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.15)';
                        }
                      }}>
                                        <HelpCircle size={14} />
                                        Ask Question
                                      </button>
                                    </div>}
                                  
                                  <span className="chatbot-widget-message-timestamp">
                                    {message.timestamp.toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit'
                      })}
                                  </span>
                                  {message.sender === 'bot' && admin && <div className="chatbot-widget-message-actions">
                                      <button onClick={() => handleEditMessage(message)} className="chatbot-widget-button" style={{
                        color: botTextColor
                      }}>
                                        <Edit style={{
                          width: '12px',
                          height: '12px'
                        }} />
                                      </button>
                                    </div>}
                                </>}
                            </div>
                          </div>
                        ))}
                        
                        {/* Typing Indicator */}
                        {isTyping && (
                          <div 
                            className="chatbot-widget-message chatbot-widget-message-bot"
                            style={{}}
                          >
                            <div className={`chatbot-widget-message-bubble chatbot-widget-message-bubble-bot ${isMobile ? 'message-bubble-mobile' : ''}`} style={{
                  backgroundColor: secondaryColor,
                  color: botTextColor,
                  border: `1px solid ${secondaryColor === '#f1f5f9' ? '#e2e8f0' : 'rgba(0,0,0,0.1)'}`
                }}>
                              <div className="chatbot-widget-typing">
                                <div className="chatbot-widget-typing-dot" />
                                <div className="chatbot-widget-typing-dot" />
                                <div className="chatbot-widget-typing-dot" />
                              </div>
                            </div>
                          </div>
                        )}
                        <div ref={messagesEndRef} />
                      </div>
                    )}
                    </div>
          
                    {/* Enhanced Input with conditional Voice Controls */}
                    <div className={`chatbot-widget-input ${isMobile ? 'input-area-mobile' : ''}`} style={{
            flex: '0 0 auto',
            padding: '0.75rem',
            backgroundColor: chatBackground,
            borderTop: '1px solid #e5e7eb',
            boxShadow: '0 -2px 10px rgba(0,0,0,0.05)'
          }}>
                      {/* Call AI Voice Agent Button - only show if no user messages sent yet and ElevenLabs is enabled */}
                      {!messages.some(msg => msg.sender === 'user') && isElevenLabsEnabled && elevenLabsAgentId && (
                        <button 
                          onClick={() => setIsCallMode(true)}
                          className="w-full mb-3 py-3 px-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg transition-colors duration-200 flex items-center justify-center gap-2"
                          style={{
                            backgroundColor: primaryColor,
                            fontSize: '16px',
                            fontWeight: '600'
                          }}
                        >
                          <Phone style={{ width: '20px', height: '20px' }} />
                          Call our AI Voice Agent
                        </button>
                      )}
                      
                      <div className="chatbot-widget-input-container" style={{
                        display: 'flex',
                        gap: '0.5rem',
                        alignItems: 'flex-end'
                      }}>
                        <textarea 
                          ref={inputRef} 
                          value={inputMessage} 
                          onChange={e => {
                            setInputMessage(e.target.value);
                            // Simple auto-resize
                            if (inputRef.current) {
                              inputRef.current.style.height = '44px';
                              const newHeight = Math.min(inputRef.current.scrollHeight, isMobile ? 120 : 100);
                              inputRef.current.style.height = newHeight + 'px';
                            }
                          }} 
                          onKeyDown={handleKeyPress}
                          placeholder={isVoiceEnabled && isRecording ? 'Listening...' : isVoiceEnabled && isProcessing ? 'Processing...' : placeholder} 
                          disabled={isLoading || isVoiceEnabled && (isRecording || isProcessing)} 
                          className="chatbot-widget-input-field" 
                          style={{
                            color: botTextColor,
                            opacity: isVoiceEnabled && (isRecording || isProcessing) ? 0.7 : 1,
                            minHeight: '44px',
                            maxHeight: isMobile ? '120px' : '100px',
                            resize: 'none',
                            overflow: inputMessage.trim() ? 'auto' : 'hidden',
                            lineHeight: '1.5',
                            padding: '0.6875rem 1rem', // Calculated to center single line of text
                            boxSizing: 'border-box',
                            fontSize: '16px' // Prevent zoom on iOS
                          }} 
                          autoComplete="off" 
                          autoCorrect="off" 
                          autoCapitalize="sentences" 
                          spellCheck="true" 
                          rows={1}
                        />
                        
                        {/* Voice Controls - only show if voice is enabled */}
                        {isVoiceEnabled && <VoiceControls isRecording={isRecording} isProcessing={isProcessing} recordingTimer={recordingTimer} isSpeaking={isSpeaking} voicePermissionDenied={voicePermissionDenied} isVoiceEnabled={isVoiceMode} onStartRecording={startRecording} onStopRecording={stopRecording} onStopSpeaking={stopSpeaking} onToggleVoice={toggleVoiceMode} primaryColor={primaryColor} />}
                        
                        {/* Send Button */}
                        <button onClick={() => {
                if (inputMessage.trim() && !isTyping) {
                  sendMessage(inputMessage);
                  // Reset textarea height after sending
                  if (inputRef.current) {
                    inputRef.current.style.height = '44px';
                  }
                }
              }} disabled={isLoading || !inputMessage.trim() || isVoiceEnabled && (isRecording || isProcessing)} className="chatbot-widget-send-button" style={{
                backgroundColor: primaryColor,
                alignSelf: 'flex-end',
                marginBottom: '2px'
              }}>
                          <Send style={{
                  width: '14px',
                  height: '14px'
                }} />
                        </button>
                      </div>
          
                      {/* Voice Settings - only show when voice mode is enabled */}
                      {isVoiceEnabled && isVoiceMode && <VoiceSettings selectedVoice={selectedVoice} onVoiceChange={setSelectedVoice} autoPlayResponses={autoPlayResponses} onAutoPlayToggle={toggleAutoPlay} primaryColor={primaryColor} />}
                    </div>
                  </>}
            </>}
        </div>}

      {/* Chat Bubble Widget - Only show when chat is closed */}
      {!isOpen && <div className="voice-chat-widget" style={{ position: 'fixed', bottom: '20px', right: '20px', zIndex: 9999 }}>
        <div className="chat-bubble" style={{
          background: '#ffffff',
          borderRadius: isSmallMobile ? '18px' : isMobile ? '20px' : '24px',
          padding: isSmallMobile ? '10px 14px' : isMobile ? '12px 16px' : '16px 20px',
          boxShadow: '0 4px 24px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08)',
          maxWidth: isSmallMobile ? '240px' : isMobile ? '280px' : '380px',
          cursor: 'pointer'
        }} onClick={handleChatButtonClick}>
          {/* Header with avatar and message */}
          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: isSmallMobile ? '8px' : isMobile ? '10px' : '12px',
            marginBottom: isSmallMobile ? '10px' : isMobile ? '12px' : '16px'
          }}>
            {/* Avatar circle */}
            <div style={{
              width: isSmallMobile ? '32px' : isMobile ? '36px' : '48px',
              height: isSmallMobile ? '32px' : isMobile ? '36px' : '48px',
              background: avatarSrc ? (logoBackgroundColor || 'transparent') : primaryColor,
              borderRadius: '50%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              flexShrink: 0,
              overflow: 'hidden'
            }}>
              {avatarSrc ? (
                <img 
                  src={avatarSrc} 
                  alt="Avatar" 
                  style={{
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain',
                    imageRendering: 'crisp-edges',
                    filter: 'contrast(1.05) saturate(1.1)'
                  }}
                  onError={e => {
                    console.error('Avatar logo failed to load:', avatarSrc);
                    e.currentTarget.style.display = 'none';
                  }}
                />
              ) : (
                <div style={{
                  color: '#ffffff',
                  fontSize: isSmallMobile ? '8px' : isMobile ? '9px' : '11px',
                  fontWeight: '600',
                  textAlign: 'center',
                  lineHeight: '1.2'
                }}>
                  {companyName.split(' ').slice(0, 2).join('\n').toUpperCase() || 'AI'}
                </div>
              )}
            </div>
            
            {/* Message text */}
            <div style={{ flex: 1 }}>
              <p style={{
                color: '#1a1a1a',
                fontSize: isSmallMobile ? '12px' : isMobile ? '13px' : '15px',
                lineHeight: '1.4',
                margin: 0,
                display: 'flex',
                alignItems: 'center'
              }}>
                {isSmallMobile 
                  ? `Hi! I'm ${agentName}.`
                  : `Hey! I'm ${agentName}. Ask me anything!`
                }
              </p>
            </div>
          </div>
          
          {/* Call button */}
          <button style={{
            background: primaryColor,
            color: '#ffffff',
            border: 'none',
            borderRadius: isSmallMobile ? '18px' : isMobile ? '20px' : '24px',
            padding: isSmallMobile ? '10px 16px' : isMobile ? '12px 18px' : '14px 24px',
            fontSize: isSmallMobile ? '13px' : isMobile ? '14px' : '16px',
            fontWeight: '600',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: isSmallMobile ? '6px' : isMobile ? '8px' : '10px',
            width: '100%',
            transition: 'all 0.2s ease'
          }} onMouseEnter={e => {
            e.currentTarget.style.background = `${primaryColor}dd`;
            e.currentTarget.style.transform = 'translateY(-1px)';
          }} onMouseLeave={e => {
            e.currentTarget.style.background = primaryColor;
            e.currentTarget.style.transform = 'translateY(0)';
          }}>
            <MessageCircle style={{ 
              width: isSmallMobile ? '14px' : isMobile ? '16px' : '20px', 
              height: isSmallMobile ? '14px' : isMobile ? '16px' : '20px' 
            }} />
            {isSmallMobile ? 'Chat' : isMobile ? 'Chat' : (callToAction || 'Start a conversation')}
          </button>
        </div>
      </div>}
    </div>
  );
};